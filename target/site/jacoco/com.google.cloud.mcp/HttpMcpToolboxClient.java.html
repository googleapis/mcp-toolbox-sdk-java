<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpMcpToolboxClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MCP Toolbox SDK for Java</a> &gt; <a href="index.source.html" class="el_package">com.google.cloud.mcp</a> &gt; <span class="el_source">HttpMcpToolboxClient.java</span></div><h1>HttpMcpToolboxClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.mcp;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.auth.oauth2.GoogleCredentials;
import com.google.auth.oauth2.IdTokenProvider;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

/** Default implementation using Java 11 HttpClient. */
public class HttpMcpToolboxClient implements McpToolboxClient {

  private final String baseUrl;
  private final String apiKey;
  private final HttpClient httpClient;
  private final ObjectMapper objectMapper;

<span class="nc" id="L44">  public HttpMcpToolboxClient(String baseUrl, String apiKey) {</span>
<span class="nc" id="L45">    this.baseUrl = baseUrl;</span>
<span class="nc" id="L46">    this.apiKey = apiKey;</span>
<span class="nc" id="L47">    this.httpClient = HttpClient.newBuilder().connectTimeout(Duration.ofSeconds(10)).build();</span>
<span class="nc" id="L48">    this.objectMapper = new ObjectMapper();</span>
<span class="nc" id="L49">  }</span>

  @Override
  public CompletableFuture&lt;Map&lt;String, ToolDefinition&gt;&gt; listTools() {
<span class="nc" id="L53">    return CompletableFuture.supplyAsync(this::getAuthorizationHeader)</span>
<span class="nc" id="L54">        .thenCompose(authHeader -&gt; sendGetRequest(&quot;/api/toolset&quot;, authHeader));</span>
  }

  @Override
  public CompletableFuture&lt;Map&lt;String, ToolDefinition&gt;&gt; loadToolset(String toolsetName) {
<span class="nc" id="L59">    return CompletableFuture.supplyAsync(this::getAuthorizationHeader)</span>
<span class="nc" id="L60">        .thenCompose(authHeader -&gt; sendGetRequest(&quot;/api/toolset/&quot; + toolsetName, authHeader));</span>
  }

  @Override
  public CompletableFuture&lt;Map&lt;String, Tool&gt;&gt; loadToolset(
      String toolsetName,
      Map&lt;String, Map&lt;String, Object&gt;&gt; paramBinds,
      Map&lt;String, Map&lt;String, AuthTokenGetter&gt;&gt; authBinds,
      boolean strict) {

    // 1. Determine which fetch method to use
    CompletableFuture&lt;Map&lt;String, ToolDefinition&gt;&gt; definitionsFuture =
<span class="nc bnc" id="L72" title="All 4 branches missed.">        (toolsetName == null || toolsetName.isEmpty()) ? listTools() : loadToolset(toolsetName);</span>

<span class="nc" id="L74">    return definitionsFuture.thenApply(</span>
        defs -&gt; {
          // 2. Strict Mode Validation
<span class="nc bnc" id="L77" title="All 2 branches missed.">          if (strict) {</span>
<span class="nc" id="L78">            Set&lt;String&gt; unknownTools = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (paramBinds != null) unknownTools.addAll(paramBinds.keySet());</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">            if (authBinds != null) unknownTools.addAll(authBinds.keySet());</span>

            // Remove all valid tools from the set of keys we are trying to bind to
<span class="nc" id="L83">            unknownTools.removeAll(defs.keySet());</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (!unknownTools.isEmpty()) {</span>
<span class="nc" id="L86">              throw new IllegalArgumentException(</span>
                  &quot;Strict mode error: Bindings provided for unknown tools: &quot; + unknownTools);
            }
          }

          // 3. Build Tool Objects &amp; Apply Bindings
<span class="nc" id="L92">          Map&lt;String, Tool&gt; tools = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">          for (Map.Entry&lt;String, ToolDefinition&gt; entry : defs.entrySet()) {</span>
<span class="nc" id="L94">            String toolName = entry.getKey();</span>
<span class="nc" id="L95">            Tool tool = new Tool(toolName, entry.getValue(), this);</span>

            // Apply Parameter Bindings
<span class="nc bnc" id="L98" title="All 4 branches missed.">            if (paramBinds != null &amp;&amp; paramBinds.containsKey(toolName)) {</span>
<span class="nc" id="L99">              paramBinds.get(toolName).forEach(tool::bindParam);</span>
            }

            // Apply Auth Bindings
<span class="nc bnc" id="L103" title="All 4 branches missed.">            if (authBinds != null &amp;&amp; authBinds.containsKey(toolName)) {</span>
<span class="nc" id="L104">              authBinds.get(toolName).forEach(tool::addAuthTokenGetter);</span>
            }

<span class="nc" id="L107">            tools.put(toolName, tool);</span>
<span class="nc" id="L108">          }</span>
<span class="nc" id="L109">          return tools;</span>
        });
  }

  private CompletableFuture&lt;Map&lt;String, ToolDefinition&gt;&gt; sendGetRequest(
      String path, String authHeader) {
    HttpRequest.Builder requestBuilder =
<span class="nc" id="L116">        HttpRequest.newBuilder().uri(URI.create(baseUrl + path)).GET();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">    if (authHeader != null) requestBuilder.header(&quot;Authorization&quot;, authHeader);</span>

<span class="nc" id="L119">    return httpClient</span>
<span class="nc" id="L120">        .sendAsync(requestBuilder.build(), HttpResponse.BodyHandlers.ofString())</span>
<span class="nc" id="L121">        .thenApply(this::handleListToolsResponse);</span>
  }

  @Override
  public CompletableFuture&lt;Tool&gt; loadTool(String toolName) {
<span class="nc" id="L126">    return loadTool(toolName, Collections.emptyMap());</span>
  }

  @Override
  public CompletableFuture&lt;Tool&gt; loadTool(
      String toolName, Map&lt;String, AuthTokenGetter&gt; authTokenGetters) {
<span class="nc" id="L132">    return CompletableFuture.supplyAsync(this::getAuthorizationHeader)</span>
<span class="nc" id="L133">        .thenCompose(</span>
            authHeader -&gt; {
              HttpRequest.Builder requestBuilder =
<span class="nc" id="L136">                  HttpRequest.newBuilder().uri(URI.create(baseUrl + &quot;/api/tool/&quot; + toolName)).GET();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">              if (authHeader != null) requestBuilder.header(&quot;Authorization&quot;, authHeader);</span>

<span class="nc" id="L139">              return httpClient</span>
<span class="nc" id="L140">                  .sendAsync(requestBuilder.build(), HttpResponse.BodyHandlers.ofString())</span>
<span class="nc" id="L141">                  .thenApply(</span>
                      res -&gt; {
<span class="nc" id="L143">                        ToolDefinition def = handleLoadToolResponse(res, toolName);</span>
<span class="nc" id="L144">                        Tool tool = new Tool(toolName, def, this);</span>
<span class="nc" id="L145">                        authTokenGetters.forEach(tool::addAuthTokenGetter);</span>
<span class="nc" id="L146">                        return tool;</span>
                      });
            });
  }

  @Override
  public CompletableFuture&lt;ToolResult&gt; invokeTool(String toolName, Map&lt;String, Object&gt; arguments) {
<span class="nc" id="L153">    return invokeTool(toolName, arguments, Collections.emptyMap());</span>
  }

  @Override
  public CompletableFuture&lt;ToolResult&gt; invokeTool(
      String toolName, Map&lt;String, Object&gt; arguments, Map&lt;String, String&gt; extraHeaders) {
<span class="nc" id="L159">    return CompletableFuture.supplyAsync(this::getAuthorizationHeader)</span>
<span class="nc" id="L160">        .thenCompose(</span>
            adcHeader -&gt; {
              try {
<span class="nc" id="L163">                String requestBody = objectMapper.writeValueAsString(arguments);</span>
                HttpRequest.Builder requestBuilder =
<span class="nc" id="L165">                    HttpRequest.newBuilder()</span>
<span class="nc" id="L166">                        .uri(URI.create(baseUrl + &quot;/api/tool/&quot; + toolName + &quot;/invoke&quot;))</span>
<span class="nc" id="L167">                        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span>
<span class="nc" id="L168">                        .POST(HttpRequest.BodyPublishers.ofString(requestBody));</span>

                // Priority Logic: If tool provides 'Authorization', use it. Else use ADC.
<span class="nc bnc" id="L171" title="All 2 branches missed.">                if (extraHeaders.containsKey(&quot;Authorization&quot;)) {</span>
                  // Tool specific auth wins
<span class="nc bnc" id="L173" title="All 2 branches missed.">                } else if (adcHeader != null) {</span>
<span class="nc" id="L174">                  requestBuilder.header(&quot;Authorization&quot;, adcHeader);</span>
                }
<span class="nc" id="L176">                extraHeaders.forEach(requestBuilder::header);</span>

<span class="nc" id="L178">                return httpClient</span>
<span class="nc" id="L179">                    .sendAsync(requestBuilder.build(), HttpResponse.BodyHandlers.ofString())</span>
<span class="nc" id="L180">                    .thenApply(response -&gt; handleInvokeResponse(response, toolName));</span>

<span class="nc" id="L182">              } catch (Exception e) {</span>
<span class="nc" id="L183">                return CompletableFuture.failedFuture(e);</span>
              }
            });
  }

  private String getAuthorizationHeader() {
<span class="nc bnc" id="L189" title="All 4 branches missed.">    if (this.apiKey != null &amp;&amp; !this.apiKey.isEmpty()) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">      return this.apiKey.startsWith(&quot;Bearer &quot;) ? this.apiKey : &quot;Bearer &quot; + this.apiKey;</span>
    }
    try {
<span class="nc" id="L193">      GoogleCredentials credentials = GoogleCredentials.getApplicationDefault();</span>
<span class="nc" id="L194">      credentials.refreshIfExpired();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      if (credentials instanceof IdTokenProvider) {</span>
        // If we can get a token for the base URL, we use it for global auth
<span class="nc" id="L197">        return &quot;Bearer &quot;</span>
            + ((IdTokenProvider) credentials)
<span class="nc" id="L199">                .idTokenWithAudience(this.baseUrl, java.util.List.of())</span>
<span class="nc" id="L200">                .getTokenValue();</span>
      }
<span class="nc" id="L202">    } catch (Exception e) {</span>
      // ADC not available or not OIDC-compatible. Proceed without global auth.
<span class="nc" id="L204">    }</span>
<span class="nc" id="L205">    return null;</span>
  }

  private Map&lt;String, ToolDefinition&gt; handleListToolsResponse(HttpResponse&lt;String&gt; response) {
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (response.statusCode() != 200)</span>
<span class="nc" id="L210">      throw new RuntimeException(&quot;Failed to list tools. Status: &quot; + response.statusCode());</span>
    try {
<span class="nc" id="L212">      JsonNode root = objectMapper.readTree(response.body());</span>
<span class="nc" id="L213">      return objectMapper.convertValue(</span>
<span class="nc" id="L214">          root.get(&quot;tools&quot;), new TypeReference&lt;Map&lt;String, ToolDefinition&gt;&gt;() {});</span>
<span class="nc" id="L215">    } catch (Exception e) {</span>
<span class="nc" id="L216">      throw new RuntimeException(e);</span>
    }
  }

  private ToolDefinition handleLoadToolResponse(HttpResponse&lt;String&gt; response, String toolName) {
<span class="nc" id="L221">    Map&lt;String, ToolDefinition&gt; tools = handleListToolsResponse(response);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (tools.containsKey(toolName)) return tools.get(toolName);</span>
<span class="nc" id="L223">    throw new RuntimeException(&quot;Tool not found: &quot; + toolName);</span>
  }

  private ToolResult handleInvokeResponse(HttpResponse&lt;String&gt; response, String toolName) {
<span class="nc" id="L227">    String body = response.body();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">    if (response.statusCode() != 200) {</span>
<span class="nc" id="L229">      return new ToolResult(</span>
<span class="nc" id="L230">          java.util.List.of(</span>
<span class="nc" id="L231">              new ToolResult.Content(&quot;text&quot;, &quot;Error &quot; + response.statusCode() + &quot;: &quot; + body)),</span>
          true);
    }
    try {
<span class="nc" id="L235">      ToolResult result = objectMapper.readValue(body, ToolResult.class);</span>
      // Robust check: if content is null (schema mismatch), wrap body as text
<span class="nc bnc" id="L237" title="All 2 branches missed.">      if (result.content() == null) {</span>
<span class="nc" id="L238">        return new ToolResult(</span>
<span class="nc" id="L239">            java.util.List.of(new ToolResult.Content(&quot;text&quot;, body)), result.isError());</span>
      }
<span class="nc" id="L241">      return result;</span>
<span class="nc" id="L242">    } catch (Exception e) {</span>
      // Parsing failed, return raw body
<span class="nc" id="L244">      return new ToolResult(java.util.List.of(new ToolResult.Content(&quot;text&quot;, body)), false);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>